+++
title = "Intro++ to Go Interfaces"
date = 2014-05-13T07:08:00Z
updated = 2014-06-04T06:21:52Z
tags = ["Go", "programming", "golang"]
blogimport = true 
type = "post"
[author]
	name = "Nate Finch"
	uri = "https://plus.google.com/115818189328363361527"
+++

<span style="font-size: large;"><b> Standard Interface Intro</b></span><br /><br />Go's interfaces are one of it's best features, but they're also one of the most confusing for newbies. &nbsp;This post will try to give you the understanding you need to use Go's interfaces and not get frustrated when things don't work the way you expect. &nbsp;It's a little long, but a bunch of that is just code examples.<br /><br />Go's interfaces are different than interfaces in other languages, they are <i>implicitly</i>&nbsp;fulfilled. &nbsp;This means that you never need to mark your type as explicitly implementing the interface (like class CFoo implements IFoo). &nbsp;Instead, your type just needs to have the methods defined in the interface, and the compiler does the rest.<br /><br />For example:<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">type Walker interface {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; Walk(miles int)</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span> <span style="font-family: Courier New, Courier, monospace; font-size: x-small;">type Camel struct {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; Name string</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span> <span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func (c Camel) Walk(miles int) {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp;fmt.Printf("%s is walking %v miles\n", c.Name, miles)</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span> <span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func LongWalk(w Walker) {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp;w.Walk(500)</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp;w.Walk(500)</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span> <span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func main() {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; c := Camel{"Bill"}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; LongWalk(c)</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span> <span style="font-family: Courier New, Courier, monospace; font-size: x-small;">// prints</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">// Bill is walking 500 miles.</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">// Bill is walking 500 miles.</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><a href="http://play.golang.org/p/erodX-JplO" target="_blank"> http://play.golang.org/p/erodX-JplO</a><br /><br />Camel implements the Walker interface, because it has a method named Walk that takes an int and doesn't return anything. &nbsp;This means you can pass it into the LongWalk function, even though you never specified that your Camel is a Walker. &nbsp;In fact, Camel and Walker can live in totally different packages and never know about one another, and this will still work if a third package decides to make a Camel and pass it into LongWalk.<br /><br /><span style="font-size: large;"><b> Non-Standard Continuation</b></span><br /><br />This is where most tutorials stop, and where most questions and problems begin. &nbsp;The problem is that you still don't know how the interfaces actually *work*, and since it's not actually that complicated, let's talk about that.<br /><br /><b> What <i>actually</i> happens when you pass Camel into LongWalk?</b><br /><div><br />So, first off, you're not passing Camel into LongWalk. &nbsp;You're actually assigning c, a value of type Camel to a value w of type Walker, and w is what you operate on in LongWalk.</div><div><br /></div><div>Under the covers, the Walker interface (like all interfaces), would look more or less like this if it were in Go (the <a href="http://golang.org/src/pkg/runtime/iface.c" target="_blank">actual code</a> is in C, so this is just a really rough approximation that is easier to read).</div><div><br /></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">type Walker struct {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; type *InterfaceType</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; data *void</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">type InterfaceType struct {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; valtype *gotype</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; func0 *func</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; func1 *func</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; ...</span></div><div><span style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">}</span></div><div><br /></div><div>All interfaces values are just two pointers - one pointer to information about the interface type, and one pointer to the data from the value you passed into the interface (a void* in C-like languages... this should probably be Go's unsafe.Pointer, but I liked the explicitness of two actual *'s in the struct to show it's just two pointers).</div><div><br /></div><div>The InterfaceType contains a pointer to information about the type of the value that you passed into the interface (valtype). &nbsp;It also contains pointers to the methods that are available on the interface.&nbsp;</div><div><br /></div><div>When you assign c to w, the compiler generates instructions that looks more or less like this (it's not actually generating Go, this is just an easier-to-read approximation):</div><div><br /></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">data := c</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">w := Walker{&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; type: &amp;InterfaceType{&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valtype: &amp;typeof(c),&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func0: &amp;Camel.Walk&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; data: &amp;data</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div><div><br /></div><div>When you assign your Camel value c to the Walker value w, the Camel type is copied into the interface value's Type.valtype field. &nbsp;The actual data in the value of c is copied into a new place in memory, and w's Data field points at that memory location.<br /><br /></div><b> Implications of the Implementation</b><br /><div><br />Now, let's look at the implications of this code. &nbsp;First, interface values are very small - just two pointers. &nbsp;When you assign a value to an interface, that value gets copied once, into the interface, but after that, it's held in a pointer, so it doesn't get copied again if you pass the interface around.</div><div><br /></div><div>So now you know why you don't need to pass around pointers to interfaces - they're small anyway, so you don't have to worry about copying the memory, plus they hold your data in a pointer, so changes to the data will travel with the interface.<br /><br /></div><b><span style="font-size: large;" id="Types">Interfaces Are Types</span></b><br /><div><br />Let's look at Walker again, this is important:</div><div><div><br /></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><b>type</b>&nbsp;Walker interface</span></div><div><br /></div><div>Note that first word there: type. &nbsp;Interfaces are types, just like string is a type or Camel is a type. &nbsp;They aren't aliases, they're not magic hand-waving, they're real types and real values which are distinct from the type and value that gets assigned to them.</div></div><div><br /></div>Now, let's assume you have this function:<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func LongWalkAll(walkers []Walker) {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; for _, w := range walkers {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; LongWalk(w)</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; }</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><br />And let's say you have a caravan of Camels that you want to send on a long walk:<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">caravan := []Camel{ Camel{"Bill"}, Camel{"Bob"}, Camel{"Steve"}}</span><br /><br />You want to pass caravan into LongWalkAll, will the compiler let you? &nbsp;Nope. &nbsp;Why is that? &nbsp;Well, []Walker is a specific type, it's a slice of values of type Walker. &nbsp;It's not shorthand for "a slice of anything that matches the Walker interface". &nbsp;It's an actual distinct type, the way []string is different from []int. &nbsp;The Go compiler will output code to assign a single value of Camel to a single value of Walker. &nbsp;That's the only place it'll help you out. &nbsp;So, with slices, you have to do it yourself:<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">walkers := make([]Walker, len(caravan))</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">for n, c := range caravan {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; walkers[n] = c</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">LongWalkAll(walkers)</span><br /><br />However, there's a better way if you know you'll just need the caravan for passing into LongWalkAll:<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">caravan := []Walker{&nbsp;Camel</span><span style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">{"Bill"}, Camel{"Bob"}, Camel{"Steve"}}</span><br /><div><span style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">LongWalkAll(caravan)</span><br /><span style="font-family: 'Courier New', Courier, monospace; font-size: x-small;"><br /></span> <br /><span style="font-family: inherit;">Note that this goes for any type which includes an interface as part of its definition: there's no automatic conversion of your func(Camel) into func(Walker) or map[string]Camel into map[string]Walker. &nbsp;Again, they're totally different types, they're not shorthand, and they're not aliases, and they're not just a pattern for the compiler to match.</span><br /><span style="font-family: inherit;"><br /></span><b><span style="font-size: large;"> Interfaces and the Pointers That Satisfy Them</span></b></div><div><br />What if Camel's Walk method had this signature instead?</div><div><br /></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func (c *Camel) Walk(miles int)</span></div><div><br /></div><div>This line says that the type *Camel has a function called Walk. &nbsp;This is important: *Camel is a type. &nbsp;It's the "pointer to a Camel" type. &nbsp;It's a distinct type from (non-pointer) Camel. &nbsp;The part about it being a pointer is <i>part of its type</i>. &nbsp;The Walk method is on the type *Camel. &nbsp;The Walk method (in this new incarnation) <i>is not on the type Camel</i>. This becomes important when you try to assign it to an interface.</div><div><br /></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">c := Camel{"Bill"}</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">LongWalk(c)</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">// compiler output:</span></div><div><pre><span class="stderr"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">cannot use c (type Camel) as type Walker in function argument:<br /> Camel does not implement Walker (Walk method has pointer receiver)</span></span></pre><pre><span class="stderr"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></span></pre><div>To pass a Camel into LongWalk now, you need to pass in a pointer to a Camel:<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">c := &amp;Camel{"Bill"}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">LongWalk(c)</span><br /><br />or<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">c := Camel{"Bill"}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">LongWalk(&amp;c)</span><br /><br />Note that this true even though you can still call Walk directly on Camel:<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">c := Camel{"Bill"}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">c.Walk(500) // this works</span><br /><br />The reason you can do that is that the Go compiler automatically converts this line to (&amp;c).Walk(500) for you. &nbsp;However, that doesn't work for passing the value into an interface. &nbsp;The reason is that the value in an interface is in a hidden memory location, and so the compiler can't automatically get a pointer to that memory for you (in Go parlance, this is known as being "not addressable").<br /><br /><b><span style="font-size: large;" id="NilPointers">Nil Pointers and Nil Interfaces</span></b></div></div><div><br />The interaction between nil interfaces and nil pointers is where nearly everyone gets tripped up when they first start with Go.</div><div><br /></div><div>Let's say we have our Camel type with the Walk method defined on *Camel as above, and we want to make a function that returns a Walker that is actually a Camel (note that you don't need a function to do this, you can just assign a *Camel to a Walker, but the function is a good illustrative example):</div><div><br /></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func MakeWalker() Walker {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; return &amp;Camel{"Bill"}</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">w := MakeWalker()</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">if w != nil {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; w.Walk(500) &nbsp;// we will hit this</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div><div><br /></div><div>This works fine. &nbsp;But now, what if we do something a little different:</div><div><br /></div><div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func MakeWalker(c *Camel) Walker {</span></div><div><span style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">&nbsp; &nbsp; return c</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">var c *Camel</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">w := MakeWalker(c)</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">if w != nil {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; // we'll get in here, but why?</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; w.Walk(500)</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div>This code will <i>also</i>&nbsp;get inside the if statement (and then panic, which we'll talk about in a bit)&nbsp;because the returned Walker value is not nil. &nbsp;How is that possible, if we returned a nil pointer? &nbsp;Well, let's go look back to the instructions that get generated when we assign a value to an interface. &nbsp;</div><div><br /></div><div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">data := c</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">w := Walker{&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; type: &amp;InterfaceType{&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valtype: &amp;typeof(c),&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func0: &amp;Camel.Walk&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; data: &amp;data</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><br /><span style="font-family: inherit;">In this case, c is a nil pointer. However, that's a perfectly valid value to assign to the Walker's Data value, so it works just fine. &nbsp;What you return is a non-nil Walker value, that has a pointer to a nil *Camel as its data. &nbsp;So, of course, if you check w == nil, the answer is false, w is not nil... but then inside the if statement, we try to call Camel's walk:</span><br /><span style="font-family: inherit;"><br /></span> <span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func (c *Camel) Walk(miles int) {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp;fmt.Printf("%s is walking %v miles\n", c.Name, miles)</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: inherit;">And when we try to do c.Name, Go automatically turns that into (*c).Name, and the code panics with a nil pointer dereference error.</span><br /><span style="font-family: inherit;"><br /></span> <span style="font-family: inherit;">Hopefully this makes sense, given our new understanding of how interfaces wrap values, but then how do you account for nil pointers? &nbsp;Assume you want MakeWalker to return a nil interface if it gets passed a nil Camel. &nbsp;You have to explicitly assign nil to the interface:</span><br /><span style="font-family: inherit;"><br /></span> <br /><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func MakeWalker(c *Camel) Walker {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; if c == nil {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; return nil</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; }</span></div><div><span style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">&nbsp; &nbsp; return c</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span> <span style="font-family: Courier New, Courier, monospace; font-size: x-small;">var c *Camel</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">w := MakeWalker(c)</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">if w != nil {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; // Yay, we don't get here!</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; w.Walk(500)</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span> <span style="font-family: inherit;">And now, finally, the code is doing what we expect. &nbsp;When you pass in a nil *Camel, we return a nil interface. &nbsp;Here's an alternate way to write the function:</span><br /><span style="font-family: inherit;"><br /></span> <br /><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func MakeWalker(c *Camel) Walker {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; var w Walker</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; if c != nil {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; w = c</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; }</span></div><div><span style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">&nbsp; &nbsp; return w</span></div><div style="orphans: auto; text-align: start; text-indent: 0px; widows: auto;"><div style="-webkit-text-stroke-width: 0px; color: black; font-family: 'Abyssinica SIL'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-family: 'Abyssinica SIL'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;">This is slightly less optimal, but it shows the other way to get a nil interface, which is to use the zero value for the interface, which is nil.</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;"><br /></span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;">Note that you <i>can</i>&nbsp;have a nil pointer value that satisfies an interface. &nbsp;You just need to be careful not to dereference the pointer in your methods. &nbsp;For example, if *Camel's Walk method looked like this:</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;"><br /></span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func (c *Camel) Walk(miles int) {</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; fmt.Printf("I'm walking %d miles!", miles)</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><br /></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;">Note that this method does not dereference c, and therefore you can call it even if c is nil:</div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><br /></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">var c *Camel</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">c.Walk(500)</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">// prints "I'm walking 500 miles!"</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><br /></div><div style="margin: 0px;"><a href="http://play.golang.org/p/4EfyV21at9">http://play.golang.org/p/4EfyV21at9</a></div><div style="margin: 0px;"><br /></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><b><span style="font-size: large;"> Outro</span></b></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><br /></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;">I hope this article helps you better understand how interfaces works, and helps you avoid some of the common pitfalls and misconceptions newbies have about how interfaces work. &nbsp;If you want more information about the internals of interfaces and some of the optimizations that I didn't cover here, read&nbsp;<a href="http://research.swtch.com/interfaces" target="_blank">Russ Cox's article</a> on Go interfaces, I highly recommend it.</div></div></div></div></div>
